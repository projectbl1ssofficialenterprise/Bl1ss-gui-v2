local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local RequestCommand = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandModification


local Players = game:GetService("Players")

local UserInputService = game:GetService("UserInputService")

if not character:FindFirstChild('Accessory (KNIF4ELERFTAccessory)') or character:FindFirstChild("Accessory (Knife McGrabbington III)") then
ready = false

local function notify(msg)
    local MainGUI = player:FindFirstChild("PlayerGui"):FindFirstChild("MainGUI")
    if not MainGUI then
        MainGUI = Instance.new("ScreenGui", player:WaitForChild("PlayerGui"))
        MainGUI.Name = "MainGUI"
    end

    coroutine.wrap(function()
        for _, v in pairs(MainGUI:GetChildren()) do
            if v:IsA("TextLabel") then v:Destroy() end
        end

        local TextLabel = Instance.new("TextLabel")
        local Frame = Instance.new("Frame")

        TextLabel.Parent = MainGUI
        TextLabel.BackgroundColor3 = Color3.fromRGB(58, 58, 58)
        TextLabel.BorderSizePixel = 0
        TextLabel.Position = UDim2.new(0.2, 0, 0.05, -10)
        TextLabel.Size = UDim2.new(0.6, 0, 0.1, 0)
        TextLabel.Font = Enum.Font.SourceSans
        TextLabel.TextColor3 = Color3.new(1, 1, 1)
        TextLabel.TextSize = 35
        TextLabel.TextScaled = true
        TextLabel.TextYAlignment = Enum.TextYAlignment.Center
        TextLabel.TextXAlignment = Enum.TextXAlignment.Left
        TextLabel.Text = ""
        TextLabel.BackgroundTransparency = 1

        Frame.Parent = TextLabel
        Frame.BackgroundColor3 = Color3.fromRGB(49, 49, 49)
        Frame.BorderSizePixel = 0
        Frame.Transparency = 1
        Frame.Position = UDim2.new(0, 0, 1, 0)
        Frame.Size = UDim2.new(1, 0, 0, 5)

        for i = 1, 8 do
            TextLabel.BackgroundTransparency = TextLabel.BackgroundTransparency - 0.1
            TextLabel.Position = TextLabel.Position + UDim2.new(0, 0, 0, 1)
            Frame.Transparency = Frame.Transparency - 0.1
            task.wait()
        end

        msg = "  " .. msg
        for i = 1, #msg do
            TextLabel.Text = string.sub(msg, 1, i)
            task.wait()
        end

        task.wait(1)

        for i = 1, 8 do
            TextLabel.BackgroundTransparency = TextLabel.BackgroundTransparency + 0.1
            TextLabel.Position = TextLabel.Position - UDim2.new(0, 0, 0, 2)
            Frame.Transparency = Frame.Transparency + 0.1
            task.wait()
        end
        TextLabel:Destroy()
    end)()
end


RequestCommand:InvokeServer(";hat me 18268136683")

yeah=player.Backpack:FindFirstChild('Building Tools') or player.Backpack:FindFirstChild('F3X Btools!')
if yeah then
notify("This game has f3x/you have f3x so everyone gonna see what you're doing.")
task.wait(3)
notify("Press 'Z' to equip.")
elseif not yeah then
notify("LOL this game has no btools or f3x so this not gonna work here")
end

local tool
for _, v in player:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end
for _, v in game.ReplicatedStorage:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end

local remote = tool.SyncAPI.ServerEndpoint

function _(args)
    remote:InvokeServer(unpack(args))
end
function SetCollision(part, boolean)
    local args = {
        [1] = "SyncCollision",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["CanCollide"] = boolean
            }
        }
    }
    _(args)
end
    function SetLocked(part,boolean)
        local args = {
            [1] = "SetLocked",
            [2] = {
                [1] = part
            },
            [3] = boolean
        }
        _(args)
    end
function yerpp(E)
local argsCreate = {
        [1] = "CreateDecorations",
        [2] = {
            [1] = {
                ["Part"] = E,
                ["DecorationType"] = "Sparkles"
            }
        }
    }

   
    local argsSync = {
        [1] = "SyncDecorate",
        [2] = {
            [1] = {
                ["Part"] = E,
                ["DecorationType"] = "Sparkles",
                ["SparkleColor"] = Color3.fromRGB(255, 255, 0)
            } 
        } 
    }
    _(argsCreate)
    _(argsSync)
end

local knfe = character["Accessory (Knife McGrabbington III)"]

if knfe then
	local args = {
		"Remove",
		{
			knfe.Handle.SpecialMesh
		}
	}

	_(args)
end

local function Resize(part, size, ha)
	local args = {
		"SyncResize",
		{
			{
				Part = part,
				CFrame = ha,
				Size = size
			}
		}
	}
	_(args)
end

local function SetAnchor(boolean, part)
	local args = {
		"SyncAnchor",
		{
			{
				Part = part,
				Anchored = boolean
			}
		}
	}
	_(args)
end

function MovePart(part, cf)
    local args = {
        [1] = "SyncMove",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["CFrame"] = cf
            }
        }
    }
    _(args)
end

local function Color(part, color)
	local args = {
		"SyncColor",
		{
			{
				Part = part,
				Color = color,
				UnionColoring = false
			}
		}
	}
	_(args)
end
function AddMesh(part)
    local args = {
        [1] = "CreateMeshes",
        [2] = {
            [1] = {
                ["Part"] = part
            }
        }
    }
    _(args)
end

    function DestroyPart(part)
        local args = {
            [1] = "Remove",
            [2] = {
                [1] = part
            }
        }
        _(args)
    end

	function SetMesh(part,meshid,offseter)
			local args = {
				[1] = "SyncMesh",
				[2] = {
					[1] = {
            ["Offset"] = offseter,
						["Part"] = part,
						["MeshId"] = "rbxassetid://"..meshid
					}
				}
			}
			_(args)
		end
function SetTexture(part, texid)
    local args = {
        [1] = "SyncMesh",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["TextureId"] = "rbxassetid://" .. texid
            }
        }
    }
    _(args)
end

    function SetTrans(part,int)
        local args = {
            [1] = "SyncMaterial",
            [2] = {
                [1] = {
                    ["Part"] = part,
                    ["Transparency"] = int
                }
            }
        }
        _(args)
    end

spawn(function()
yerpp(knfe.Handle)
end)
spawn(function()
AddMesh(knfe.Handle)
end)
spawn(function()
SetMesh(knfe.Handle, "18114736783",Vector3.new(0, 0, 0))
end)
spawn(function()
SetTexture(knfe.Handle, "80617091791234")
end)

function bleed(target)
    if not target or not target.Character then return end
    
    local stopBleeding = false
    local activeBloodParts = {} 
    local characterConnection
    characterConnection = target.CharacterAdded:Connect(function()
        stopBleeding = true

        for _, blood in pairs(activeBloodParts) do
            if blood and blood.Parent then
                DestroyPart(blood)
            end
        end
        if characterConnection then
            characterConnection:Disconnect()
        end
    end)
    

    coroutine.wrap(function()
        while not stopBleeding and target and target.Character do
            local humanoid = target.Character:FindFirstChildOfClass("Humanoid")
            local rootPart = target.Character:FindFirstChild("HumanoidRootPart")
            
            if rootPart then

                coroutine.wrap(function()
                yez=CFrame.new(0,-10,0)
                    local blood = remote:InvokeServer("CreatePart", "Ball", yez, target.Character)
                    if blood then
                        table.insert(activeBloodParts, blood)
                        
                        spawn(function()
                        Color(blood, Color3.fromRGB(255, 0, 0))
                        end)
                    
                        spawn(function()
    Resize(blood, Vector3.new(0.2, 0.2, 0.2), rootPart.CFrame + Vector3.new(math.random(-1,1),0,math.random(-1,1)))
end)
                        spawn(function()
                        SetAnchor(false, blood)
                        end)
                        coroutine.wrap(function()
                            wait(2)
                            Resize(blood, Vector3.new(0.8, 0.1, 0.8),blood.CFrame)
                            Resize(blood, Vector3.new(0.9, 0.1, 0.9),blood.CFrame)
                            SetTrans(blood, 0.9)
                            SetTrans(blood, 0.7)
                            SetTrans(blood, 0.5)
                            SetTrans(blood, 0.3)
                            SetTrans(blood, 0.1)
                            DestroyPart(blood)
                            
                        
                            for i, v in pairs(activeBloodParts) do
                                if v == blood then
                                    table.remove(activeBloodParts, i)
                                    break
                                end
                            end
                        end)()
                    end
                end)()
            end
            
            wait(0.005)
        end
    end)()
end

function c0lefect(E)
local argsCreate = {
        [1] = "CreateDecorations",
        [2] = {
            [1] = {
                ["Part"] = E,
                ["DecorationType"] = "Sparkles"
            }
        }
    }

   
    local argsSync = {
        [1] = "SyncDecorate",
        [2] = {
            [1] = {
                ["Part"] = E,
                ["DecorationType"] = "Sparkles",
                ["SparkleColor"] = Color3.fromRGB(255, 255, 0)
            } 
        } 
    }

local args = {
	"Remove",
	{
		E:FindFirstChild('Sparkles')
	}
}



    _(argsCreate)
    _(argsSync)
task.wait(1)
    _(args)
end


			function Weld(part1, part2,lead)
				local args = {
					[1] = "CreateWelds",
					[2] = {
						[1] = part1,
						[2] = part2
					},
					[3] = lead
				}
				_(args)
	
			end
function breakWelds(part)
    local welds = {}
    for _, weld in ipairs(part:GetDescendants()) do
        if weld:IsA("WeldConstraint") or weld:IsA("Weld") or weld:IsA("Motor6D") then
            table.insert(welds, weld)
        end
    end

    if #welds == 0 then
        return false
    end

    local args = {
        "RemoveWelds",
        welds
    }
    _(args)
    return true
end

local humanoid = character:FindFirstChildOfClass("Humanoid")

local arm = character:FindFirstChild("Right Arm") and character:FindFirstChild("Left Arm") and character:FindFirstChild("Torso") 
local holdAnimation = Instance.new("Animation")
holdAnimation.AnimationId = "rbxassetid://48146273"
local holdTrack = humanoid:LoadAnimation(holdAnimation)

local killAnimation = Instance.new("Animation")
killAnimation.AnimationId = "rbxassetid://48146273"
local killTrack = humanoid:LoadAnimation(killAnimation)

local knifeHoldAnim = Instance.new("Animation")
knifeHoldAnim.AnimationId = "rbxassetid://299225058"

local staffupAnim = Instance.new("Animation")
staffupAnim.AnimationId = "rbxassetid://27432691"

local swordhitAnim = Instance.new("Animation")
swordhitAnim.AnimationId = "rbxassetid://27432686"

local holdstaffAnim = Instance.new("Animation")
holdstaffAnim.AnimationId = "rbxassetid://57794492"

local stabAnim = Instance.new("Animation")
stabAnim.AnimationId = "rbxassetid://30174375"


				local track1 = humanoid:LoadAnimation(staffupAnim)
				local track2 = humanoid:LoadAnimation(swordhitAnim)
				holdTrack = humanoid:LoadAnimation(holdstaffAnim)




function GrabAnim()
				track1.Looped = false
				track2.Looped = false
				holdTrack.Looped = false

				track1:Play()
				track1.Stopped:Wait()

				track2:Play()
				track2.Stopped:Wait()

				holdTrack:Play()
				holdTrack:AdjustSpeed(0)
end

function Kill()
local stabTrack = humanoid:LoadAnimation(stabAnim)
	stabTrack.Looped = false
	stabTrack:Play()
	stabTrack.Stopped:Wait()

	if holdTrack then holdTrack:Stop() end
end


function failed()
				track1.Looped = false
				track2.Looped = false
				holdTrack.Looped = false

				track1:Play()
        track1:AdjustSpeed(3)
				track1.Stopped:Wait()

				
         holdTrack:Play()
         wait(0.3)
         holdTrack:Stop()
end


local isBusy = false
local alignPosition
local alignOrientation

local Players = game:GetService("Players")
local player = Players.LocalPlayer 

local function attachBehind(targetChar)
    local root = character:FindFirstChild("HumanoidRootPart")
    local targetRoot = targetChar:FindFirstChild("HumanoidRootPart")
    if root and targetRoot then
        
        local attachment0 = root:FindFirstChild("Attachment") or Instance.new("Attachment", root)
        local attachment1 = targetRoot:FindFirstChild("Attachment") or Instance.new("Attachment", targetRoot)

   
        alignPosition = Instance.new("AlignPosition")
        alignPosition.MaxForce = 1000000
        alignPosition.Responsiveness = 200
        alignPosition.Attachment0 = attachment0
        alignPosition.Attachment1 = attachment1
        alignPosition.Parent = root
        alignOrientation = Instance.new("AlignOrientation")
        alignOrientation.MaxTorque = 1000000
        alignOrientation.Responsiveness = 200
        alignOrientation.Attachment0 = attachment0
        alignOrientation.Attachment1 = attachment1
        alignOrientation.Parent = root

     
        attachment1.Position = Vector3.new(0, 0, 0.5)
    end
end

local function detach()
    if alignPosition then
        alignPosition:Destroy()
        alignPosition = nil
    end
    if alignOrientation then
        alignOrientation:Destroy()
        alignOrientation = nil
    end
end

local function attacke()
    if isBusy then return end
    isBusy = true

    local hitPlayer = nil
local touchedConnection

local function onTouch(other)
    local otherPlayer = Players:GetPlayerFromCharacter(other.Parent)
    if otherPlayer and otherPlayer ~= player then
        hitPlayer = otherPlayer
    end
end

touchedConnection = arm.Touched:Connect(onTouch)
task.wait(0.15)
if touchedConnection then
    touchedConnection:Disconnect()
end

    if hitPlayer and hitPlayer.Character then
        
RequestCommand:InvokeServer(";speed " ..hitPlayer.Name.. " 0")
 
        
				track1.Looped = false
				track2.Looped = false
				holdTrack.Looped = false

				track1:Play()
				track1.Stopped:Wait()

				track2:Play()
        track2:AdjustSpeed(3)
				track2.Stopped:Wait()

				holdTrack:Play()
        
				holdTrack:AdjustSpeed(0)
spawn(function()
attachBehind(hitPlayer.Character)
wait(0.8)
detach()
end)
spawn(function()
SetLocked(hitPlayer.Character.Torso, false)
end)
spawn(function()
SetLocked(char.Torso, false)
end)
 Weld(character.Torso,hitPlayer.Character.Torso,character.Torso)
Weld(character.Torso,hitPlayer.Character.HumanoidRootPart,character.Torso)
Weld(character.Torso,hitPlayer.Character.Head,character.Torso)


wait(3)
            spawn(function()
            Kill()
            end)
            bleed(hitPlayer)
            wait(0.5)
           RequestCommand:InvokeServer(";kill " ..hitPlayer.Name)
           wait(0.5)
breakWelds(character.Torso)
breakWelds(hitPlayer.Character.Torso)
spawn(function()
wait(0.8)

spawn(function()
SetLocked(hitPlayer.Character.Torso, false)
end)
spawn(function()
SetLocked(hitPlayer.Character["Right Arm"], false)
end)
spawn(function()
SetLocked(hitPlayer.Character["Left Arm"], false)
end)
spawn(function()
SetLocked(hitPlayer.Character["Right Leg"], false)
end)
spawn(function()
SetLocked(hitPlayer.Character["Left Leg"], false)
end)

spawn(function()
SetCollision(hitPlayer.Character.Torso, true)
end)
spawn(function()
SetCollision(hitPlayer.Character["Right Arm"], true)
end)
spawn(function()
SetCollision(hitPlayer.Character["Left Arm"], true)
end)
spawn(function()
SetCollision(hitPlayer.Character["Right Leg"], true)
end)
spawn(function()
SetCollision(hitPlayer.Character["Left Leg"], true)
end)
end)

wait(0.3)
           
            
            isBusy = false
  

    else
        
        failed()
        wait(0.4)
            isBusy = false
    end
end




UserInputService.InputBegan:Connect(function(input, gameProcessed)
 if gameProcessed then return end

 if input.KeyCode == Enum.KeyCode.Z then
  local args = {
  "Remove",
  {
   knfe.Handle
  }
 }
 _(args)
 knfe:Destroy()

 RequestCommand:InvokeServer(";hat me 18420472059")
 wait(1)
 local knife = character:FindFirstChild("Accessory (KNIF4ELERFTAccessory)")

 spawn(function()
 local args = {
  "Remove",
  {
   knife.Handle.SpecialMesh
  }
 }
 _(args)
 end)

 spawn(function()
 AddMesh(knife.Handle)
 end)
 spawn(function()
 SetMesh(knife.Handle, "18114736783", Vector3.new(0, 0,-0.25))
 end)
 spawn(function()
 SetTexture(knife.Handle, "80617091791234")
 end)

 ready = true
 end 
end)




UserInputService.TouchTap:Connect(function(input, gameProcessed)
    if gameProcessed then return end
if ready == true then
    attacke()
end
end)

end

-- end knife

-- that all hope this help its a private ahh script

